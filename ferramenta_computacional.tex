\chapter{FERRAMENTA COMPUTACIONAL}\label{sec:ferramenta_computacional}

Nesta seção apresentam-se detalhes da ferramenta computacional desenvolvida para simulação do escoamento sanguíneo em modelos de árvores arteriais. A principal finalidade desta ferramenta é possibilitar a visualização de estruturas das árvores arteriais e, após a simulação hemodinâmica,  é possibilitar a visualização de estruturas das árvores arteriais e, após a simulação hemodinâmica, dos gráficos ilustrando as curvas de distribuição do fluxo sanguíneo e pressão..

Esta ferramenta foi desenvolvida em C++ utilizando as bibliotecas do Qt 5.15.0 \cite{QTClasses} e OpenGL \cite{OpenGL}, que ajudam na construção da interface gráfica e na exibição de modelos gráficos, como árvores arteriais e gráficos dos resultados. A ferramenta foi disponibilizada em dois ambientes, o primeiro nomeado de \textit{Iterador Gráfico Universal} (IGU), pois em seu modelo de classes qualquer objeto que implemente a classe \textit{WiseObject} (descrito na Seção~\ref{sec:objeto_inteligente}) está apto para realizar iterações e desenhar-se através de diretivas OpenGL em um elemento de interface gráfica. O segundo ambiente disponibilizado foi nomeado de \textit{Iterador não-Gráfico Universal} (InGU), pois segue a mesma generalização, entretanto é disponibilizada pelo console, não possuindo interface gráfica.

Buscou-se no desenvolvimento desta ferramenta alto grau de generalização para que seja possível analisar todos os parâmetros de um objeto facilmente e que ela possua grande versatilidade. \igunew{Além de árvores arteriais, a ferramenta possibilita que outros objetos sejam gerados para visualização, qualquer objeto que implemente a classe \textit{GraphicObject} (descrito na Seção~\ref{sec:objeto_grafico}) pode ser visualizado.} A Figura~\ref{fig1:gui} ilustra a ferramenta desenvolvida.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=0.25]{Figures/IGU_002.png}
	\caption{Interface gráfica da ferramenta construída.}
	\label{fig1:gui}
\end{figure}


Através da modelagem de classes no paradigma do C++ \cite{AlanParker}, foi possível realizar diversas generalizações que ampliam a adaptabilidade dos objetos que podem ser inseridos neste modelo de classes. Na Seção~\ref{sec:estrutura} é proposto um esquema de classes virtuais, ou abstratas, que foram criadas para facilitar o manuseio dos objetos dentro do ambiente computacional e prover funções básicas. 

Uma classe virtual não possui construtor próprio, porque classes virtuais são incompletas. Estas classes possuem métodos virtuais, que por sua vez precisam ser definidos pela classe herdeira. Portanto, uma classe virtual funciona como um conjunto de regras que classes herdeiras devem seguir. Todas as classes que implementem esta classe virtual devem ter sua própria definição dos métodos virtuais, podendo ter funcionamentos distintos, entretanto recebendo os mesmos parâmetros.  Adicionado este conceito à estrutura de dados, classes virtuais generalizam os objetos e garantem o seu funcionamento, separando as estruturas de acordo com seu propósito em classes.

\igunew{Nesta ferramenta computacional ponteiros foram utilizados na organização destas classes virtuais. Quando um ponteiro para uma classe abstrata é definido, é possível que diversas estruturas de dados sejam referências. Ao referenciar um objeto \textit{WiseObject} através de um ponteiro é possível acessar os métodos padrões da classe abstrata que irão acessar a implementação de cada objeto. Todos os objetos irão ter por definição um método que irá construir a estrutura, mas cada objeto irá construir suas próprias estruturas. Portanto, é possível que a ferramenta computacional envie estes dados por referência sem necessariamente reescrevê-los na memória. Este fator foi determinante na escolha da linguagem \textit{C++}, pois um ponteiro é o endereço de memória física, o que permite uma agilidade maior na organização da ferramenta e na utilização destas estruturas pela ferramenta em suas diferentes \textit{threads}.}

\footnote{Thread é um pequeno programa que trabalha como um subsistema, sendo uma forma de um processo se autodividir em duas ou mais tarefas.}

%--------------------------------------------------------------------------------%
\section{ALGORITMOS PARA OS CÁLCULOS HEMODINÂMICOS}
\label{sec:algoritmo}
%\textcolor{red}{IGOR: fiz mais uma revisão nesta seção. Cheque se tudo está coerente com o quis dizer após minhas alterações no texto.} \textcolor{green}{OK}

Nesta seção, detalham-se os algoritmos que descrevem os passos para o cálculo das equações da pressão $P$ e fluxo $Q$ definidas em \eqref{21_P} \eqref{23_Q}, respectivamente.

Inicialmente, salientam-se que as Equações~\eqref{27_R} e~\eqref{28_Ye} expõem a necessidade de valores $Y_e(k+1,2j)$ e $Y_e(k+1,2j-1)$ atrelados aos vasos adjacentes na posição distal do vaso $(k,j)$. Por outro lado, o valor da pressão média do vaso $(k,j)$ calculado usando a Equação~\eqref{18_barp} depende de valores  à montante desse vaso, ou seja, do valor $\bar{p}(k-1,s)$. Tendo isto em vista, a estrutura de dados desenvolvida utiliza ponteiros para acessar as propriedades de artérias à montante e a jusante de um vaso do modelo.

Como neste trabalho adotou-se a linguagem de programação C++, os objetos podem se passados para uma outra função por referência. Ao passar um objeto por referência, o endereço de memória é enviado, dando total acesso aos parâmetros do objeto, este endereço é chamado de ponteiro. Ao enviar o ponteiro do vaso raiz, é possível acessar todo o modelo de árvore arterial. Cada vaso arterial do modelo contém as propriedades apresentadas na Tabela~\ref{tab:info_vaso}, além de ponteiros para os vasos adjacentes. 

\begin{table}[h]
	\begin{tabularx}{\textwidth}{c|c|X|c}
		\toprule
		\textbf{valores conhecidos} & \textbf{unidade} & \textbf{valores calculados} & \textbf{unidade} \\\midrule
		
		comprimento ($L$) & cm &  velocidade da onda ($c$) & cm/s \\
		
		densidade ($\rho$) & g/cm$^3$ &   beta ($\beta$) & -- \\
		
		módulo de Young ($E$) & g/cms$^2$  & velocidade angular ($\omega$) & rad/s \\
		
		viscosidade ($\mu_0$) & cm$^2$/s &	espessura da parede ($h$) &  $cm$ \\
		
		raio ($r$) & cm  & número de Womersley ($\alpha$) & --- \\
		
		& & admitância característica ($Y$) & $cm^4 s/g $\\
		
		&  & admitância efetiva ($Y_e$) & $cm^4 s/g $\\
		
		&  & coeficiente de reflexão ($R$) & $g /cm^4 s$ \\
		
		& & fator viscoso ($\epsilon$) & -- \\
		
		& & pressão ($P$) & -- \\
		
		&  &	pressão média ($\bar{p}$) & $g/cm s^2$ \\
		
		& &	fluxo ($Q$) & -- \\
		\hline
	\end{tabularx}
	\caption{Propriedades de cada vaso arterial do modelo.}
	\label{tab:info_vaso}
\end{table}

Além das propriedades especificadas na Tabela~\ref{tab:info_vaso}, o vaso possui ainda três ponteiros para os seus vasos adjacentes. Um destes ponteiros, para o vaso adjacente ao seu nó proximal, ou seja, para o seu vaso pai $(k-1,s)$. Os demais ponteiros para os vasos adjacentes ao seu nó distal, ou seja, para seus vasos filhos à esquerda ($esq$) e à direita ($dir$) expressos por $(k+1,2j-1)$ e $(k+1,2j)$, respectivamente. Este arranjo de ponteiros é equivalente a uma árvore duplamente encadeada, onde através de um único ponteiro para um vaso é possível trafegar a árvore nos dois sentidos. Isto é útil quando é necessário acessar propriedades de outro vaso para se determinarem por exemplo, a pressão média, coeficientes de reflexão e admitâncias de um dado vaso.

Os ponteiros permitem também definir se o vaso é a raiz ou uma folha. Caso o ponteiro para o segmento superior $(k-1,s)$ seja igual ao valor da \textit{flag} nula se trata de um vaso raiz. Caso ambos vasos  $(k+1,2j-1)$ e $(k+1,2j)$ sejam iguais ao valor da \textit{flag} nula se trata de um vaso folha, isto é, um vaso terminal.

Basicamente, os passos para determinar as ondas de pressão e fluxo que percorrem um modelo de árvore arterial usando o modelo de Duan e Zamir explicado no Capítulo~\ref{sec:cenario} são dados por:

\begin{algorithm}[H]
	\SetAlgoLined
		Cálculo da admitância característica $(Y)$ de cada vaso;\\
		Cálculo da admitância efetiva $(Y_e)$  de cada vaso;\\
		Cálculo do coeficiente de reflexão $(R)$  de cada vaso; \\
		Armazenar valor da admitância característica $(Y_r)$ do vaso raiz, isto é, o valor de $Y(1,1)$;\\
		Cálculo da pressão média $(\bar{p})$ em cada vaso;\\
		Cálculo das ondas de pressão e fluxo $P$ e $Q$.
	\label{algsimples}
\end{algorithm}

Os passos acima mencionados foram organizados no Algoritmo 2.

 Esse algoritmo tem como entrada: o modelo de árvore arterial ($\mathcal{MAA}$) com seus vasos caracterizados por suas propriedades, a frequência $f$, um fator de escala da viscosidade $\gamma_{\mu}$, o parâmetro da viscoelasticidade da parede $\phi$, a amplitude da pressão média no vaso raiz $\bar{p}_0$, e a quantidade de espaçamento para discretização de um vaso $N$.

\begin{algorithm}[H]
	\SetAlgoLined
	\Entrada{ $\mathcal{MAA}$, $f$, $\gamma_{\mu}$, $\phi$, $\bar{p}_0$, $N$ }
	\Inicio{
		inicializa vaso $v$ a partir do vaso raiz;\\
		\Se{existe($v$)}{
			Chama $\mathcal{M}_1$ ($v$, $f$, $\gamma_{\mu}$, $\phi_0$) e armazena $Y_r$;
		}
		\Se{existe($Y(1,1)$)}{
			Chama $\mathcal{M}_2$($v$ , $\bar{p}_0$, $Y_r$, $N$);
		}
	Retorna $\mathcal{MAA}$ com cada vaso contendo $P$ e $Q$.
	}
	\label{Alg2}
	\caption{Cálculos hemodinâmicos do modelo de árvore arterial ($\mathcal{MAA}$).}
\end{algorithm}

O Algoritmo 2 proposto tem dois módulos, a saber: $\mathcal{M}_1$ e $\mathcal{M}_2$.

\igunew{O módulo $\mathcal{M}_1$ realiza o cálculo percorrendo o caminho a partir dos vasos finais até o vaso raiz (estratégia do tipo \textit{bottom-up}), visando} calcular os valores de admitância efetiva ($Y_e$), admitância característica ($Y$) e coeficiente de reflexão ($R$) de cada vaso. Este módulo é definido pelo Algoritmo~\ref{AlgM1}. Necessitam-se que as admitâncias efetivas dos vasos à justante do vaso $k$ ($Y_e(k+1,2j-1)$ e $Y_e(k+1,2j)$) estejam definidas. Em vista disso, verifica-se a existência dos vasos à justante do vaso atual tanto a esquerda ($esq$) quanto a direita ($dir$) e caso existam realiza-se uma chamada recursiva. Após o retorno das chamadas recursivas, calculam-se as propriedades do vaso atual. Assim, as propriedades do vasos à jusante do vaso atual serão conhecidas, ou seja, já terão sido determinadas $Y_e(k+1,2j-1)$ e $Y_e(k+1,2j)$.

\begin{algorithm}[H]
	\Inicio{
		\Se{existe($v \rightarrow esq$)}{
			$\mathcal{M}_1$ ($v \rightarrow esq$, $f$, $\gamma_{\mu}$, $\phi$);
		}
		\Se{existe($v \rightarrow dir$)}{
			$\mathcal{M}_1$ ($v \rightarrow dir$, $f$, $\gamma_{\mu}$, $\phi$);
		}
		Calcula as propriedades $c$, $\omega$, $\beta$; \\
		\Se{ ($\gamma_{\mu} == 0$) e ($\phi == 0$) }{
			Calcula $Y$;
		}
		\Senao{
			\Se{ ($\gamma_{\mu}~!=~0$) }{
				Calcula $\alpha$, $\epsilon$, $E_v$, $c_v$ e $Y_v$;\\
				Atualiza $E = E_v$, $c = c_v$ e $Y = Y_v$;
			}
			\Se{ ($\phi~!=~0$) }{
				Calcula $E_c$;\\
				Atualize $E = E_c$;
			}
		}
		\Se{($v$ é um vaso terminal)}{
			$Y_e = Y$ e  $R = 0$;
		}
		\Senao{
			Calcula $Y_e$ e $R$;
		}
	}
	\caption{$\mathcal{M}_1$ ($v$, $f$, $\gamma_{\mu}$, $\phi$) -- Cálculo das admitâncias e coeficiente de reflexão.}
	\label{AlgM1}
\end{algorithm}

\igunew{O módulo $\mathcal{M}_2$ realiza os cálculos percorrendo o modelo a partir do vaso raiz até os vasos terminais (abordagem do tipo \textit{top-bottom}), visando} calcular o valor da pressão média, pressão e fluxo em cada vaso. Este módulo é expresso no Algoritmo~\ref{AlgoritmoM2}. Como expresso na Equação~\eqref{18_barp}, o valor da pressão média requer o valor da pressão média do vaso à montante $(k-1,s)$. Logo, inicialmente, se o vaso atual é a artéria de alimentação (raiz), neste caso $\bar{p} = \bar{p}_0$. Caso contrário, calcula-se $\bar{p}$ com a Equação~\eqref{18_barp}. Em seguida, o valor das ondas de pressão e fluxo são obtidas ao longo de cada vaso 1D, que são discretizados através de $N$ espaçamentos. Por fim, a recursão é enviada aos segmentos inferiores, desta forma se garante a existência de um valor $\bar{p}(k-1,s)$.

\begin{algorithm}[H]
	$\mathcal{M}_2$ ($v$, $\bar{p}_0$, $Y_r$, $N$) \\
	\Inicio{
		\Se{ ($v$ é o vaso raiz)}{
			$\bar{p} = \bar{p_0}$;
		}
		\Senao{
			Calcula $\bar{p}$;
		}
		Calcula $P(X_i)$ e $Q(X_i)$, onde $X_i \in [0,1]$; \\
		\Se{existe( $v \rightarrow esq$ )}{
			$\mathcal{M}_2$ ($v \rightarrow esq$, $\bar{p}_0$, $Y_r$, $N$);
		}
		\Se{existe($v \rightarrow dir$)}{
			$\mathcal{M}_2$ ($v \rightarrow dir$, $\bar{p}_0$, $Y_r$, $N$);
		}
	}
	\caption{$\mathcal{M}_2$ -- Cálculo da pressão e fluxo ao longo de cada vaso.}
	\label{AlgoritmoM2}
\end{algorithm}

No Algoritmo \ref{AlgoritmoM2} tem-se que $N$ denota a quantidade de espaçamento $dX$ no intervalo [0,1] para discretização de um vaso. Assim, $dX = 1/N$ e $X_i = i dX (i = 0, 1, \cdot\cdot\cdot, N)$.

%--------------------------------------------------------------------------------%
\section{ESTRUTURA DE DADOS}\label{sec:estrutura}

Nesta seção, apresentam-se detalhes da estrutura de dados elaborada para a ferramenta computacional. Como mencionado na Seção~\ref{sec:algoritmo}~\igunew{, foi empregada uma estrutura para armazenar todas as referências às informações} do modelo geométrico da árvore arterial.

\igunew{Iterar o modelo matemático na ferramenta computacional equivale à aplicar um objeto inteligente a sua fábrica de iteração \textit{WiseIterationFactory} (descrito na Seção~\ref{sec:fabrica}). A fábrica de iteração \textit{DuanAndZamirIterationFactory} acoplada à uma árvore arterial \textit{WiseArterialTree} é equivalente a execução do Algoritmo~\ref{Alg2} em todo o modelo geométrico, definindo a onda de pressão $P$ e fluxo $Q$ em todos os segmentos.}

\igunew{ A ferramenta computacional foi desenvolvida para ser capaz de armazenar, carregar e iterar o modelo matemático e gerar novas estruturas para visualização. A estrutura de dados proposta para a ferramenta precisa realizar estar operações e armazenar corretamente os dados gerados.}

As seções \igunew{a seguir} descrevem a estrutura de dados genérica, tendo como principal objeto de estudo, o escoamento pulsátil através de um modelo de árvore arterial 1D e a visualização dos seus resultados. Em versões anteriores, a ferramenta computacional definia seus modelos matemáticos, geométricos e de visualização em apenas uma estrutura abstrata, o que acarretou em classes grandes com difícil manutenção e pouca versatilidade. Isto porque o mesmo objeto ficava responsável por diversas funções: instanciar, iterar e desenhar na tela através de diretivas OpenGL. Portanto, na versão atual da ferramenta computacional as classes foram desenvolvidas para ter propósito único, cujo objetivo é garantir que as classe tenham uma função apenas, garantindo uma classe com um número reduzido atributos e métodos, o que facilita a manutenção e entendimento.

Ao longo do desenvolvimento da ferramenta, três principais processos foram identificados: (1) a iteração dos objetos, uma vez carregados estes objetos são atualizados por algoritmos, gerando novas versões; (2) o armazenamento dos objetos, os elementos criados no método de iteração podem ser armazenados e então recuperados;  \igunew{e (3) a exibição dos objetos, os elementos carregados podem ter seus parâmetros visualizados em um elemento de interface gráfica \textit{OpenGL}~\cite{OpenGL}. O ciclo iterativo irá gerar ao final uma animação, para tanto cada iteração irá gerar um quadro desta animação. O objeto \textit{WiseObject} irá armazenar todos estes quadros, cada quadro representa um elemento \textit{WiseElement}.} Cada quadro antes de ser exibido precisa ser processado em diretivas \textit{OpenGL}, o responsável sobre esse processo é o elemento gráfico \textit{GraphicObject}. Igualmente quando se tratam de animações e reproduções de vídeo, somente quadros necessários estarão em memória. 

Finalmente, estas estruturas são utilizadas pela ferramenta computacional possibilitando que modelos geométricos sejam carregados, iterados e então exibidos, sem que haja perda dos quadros ou de algum dado. Os elementos principais da estrutura de dados serão descritos nas seções que se seguem.

%--------------------------------------------------------------------------------%
\subsection{ELEMENTO DA CLASSE}\label{sec:elemento_inteligente}

Elementos são objetos que implementam a classe \textit{WiseElement}. O principal objetivo de um elemento é manter os dados mais recentes de um modelo geométrico e os dados necessários para o método de iteração. No caso do estudo do escoamento pulsátil, considerou-se que uma iteração seja a execução completa do algoritmo apresentado na Seção~ \ref{sec:algoritmo} em toda a árvore. Portanto, cada elemento possuirá todas as informações do modelo geométrico de uma árvore arterial, seus segmentos e suas propriedades.

Através das malhas estruturadas e não estruturadas presentes na biblioteca \textit{VTK}(\textit{Visua}-\textit{lization ToolKit})~\cite{VTKUSER} é possível descrever diversas estruturas de dados através de elementos padronizados, como pontos, linhas e células. Utilizando os elementos básicos contidas nestas malhas, a estrutura básica da arquitetura foi criada e está presente na Figura~\ref{fig2:wiselement}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=2]{Figures/WiseElement@16x.png}
	\caption{Representação de classes de um elemento. \textit{WiseElement} é uma classe abstrata base e seus componentes são: \textit{WiseStructure} representa a estrutura contida em um arquivo VTK e DataStructure representa a estrutura de ponteiros e variáveis utilizadas na iteração.}
	\label{fig2:wiselement}
\end{figure}

A Figura~\ref{fig2:wiselement} mostra que um elemento inteligente é composto por duas outras estruturas:  \textit{WiseStructure} - utiliza pontos, linhas, células e campos para determinar estruturas geométricas;  \textit{DataSructure} - representa os dados abstratos específicos de cada elemento. Estas estruturas são equivalentes entre si, isto é feito para que a primeira estrutura mantenha um formato padrão de pontos, linhas, células e campos. Enquanto dados abstratos equivalentes podem ser utilizados, os dados mantidos na estrutura padrão \textit{WiseStructure} são utilizados principalmente na leitura e escrita de objetos, portanto são mantidos como vetores que possuem cadeias de caracteres, os dados presentes nesta estrutura podem ser editados pelo usuário. Enquanto os dados abstratos contém a mesma informação contida em variáveis da linguagem, como números inteiros, vetores, ponteiros e outros.

Cada parâmetro de um elemento representa uma grandeza associada à um componente do modelo geométrico (pontos,  linhas e células) ou ainda sobre todo o modelo (campos). \igunew{Os parâmetros armazenam valores definidos por um nome e uma referência ao modelo geométrico. Os raios $r$ de uma árvore arterial são dados relacionados à um vaso (segmento 1D), que é representado por uma linha. Como só existe um raio por segmento, somente um valor será armazenado. Os valores de pressão $P$ através de um segmento com $X \in [0,1]$ estão relacionados ao mesmo componente geométrico, mas são representados por uma sequência de valores. A estrutura de parâmetros permite que sejam armazenados um ou múltiplos valores no mesmo local e os acesse da mesma forma. Ao acessar o valor do raio $r$ de um segmento, um vetor é recebido com apenas uma posição e ao acessar a pressão $P$ são esperados $N$ elementos.}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\textwidth]{Figures/WiseElements@16x.png}
	\caption{Tipos de elementos. \textit{WiseGraphic}, um gráfico bidimensional. \textit{WiseMesh}, uma malha tridimensional. \textit{WisePoly}, um cubo. \textit{WiseArteryTree}, uma árvore arterial.}
	\label{fig2:wiselements}
\end{figure}

Como ilustrado na Figura~\ref{fig2:wiselements} um elemento é aquele que implementa a classe abstrata \textit{WiseElement}. Os dados abstratos \textit{DataStructure} de cada classe podem ser salvos na estrutura padrão \textit{WiseStructure} e utilizados quando necessário. 

O modelo geométrico de uma árvore arterial foi traduzido para o elemento \textit{WiseArteryTree}. A estrutura deste elemento conta com pontos e linhas que definem os parâmetros do modelo geométrico na estrutura \textit{WiseStructure}. A estrutura abstrata \textit{DataStructure} conta com ponteiros para cada segmento e grandezas físicas armazenadas em pontos flutuantes de precisão dupla.

\igunew{Foram criados ainda outros elementos, como \textit{WiseGraphic} que representa um gráfico, \textit{WiseMesh} representa um plano e o elemento \textit{WisePoly} representa um cubo. A seguir mais detalhes sobre estes elementos.}

O elemento \textit{WiseGraphic} foi criado para armazenar dados ao longo de uma dimensão, como a pressão ao longo da árvore arterial. Os elementos \textit{WiseMesh} e \textit{WisePoly} foram criados para armazenar dados ao longo ao longo de duas e três dimensões  respectivamente,  e foram utilizados como exemplo de objetos que podem ser generalizados na ferramenta e visualizados mudando pouco as estruturas já existentes. O elemento \textit{WiseGraphic} é equivalente a um vetor de valores $(x,v)$, o elemento \textit{WiseMesh} é equivalente a uma matriz de valores $(x,y,v)$ e o elemento \textit{WisePoly} é equivalente a uma matriz tridimensional de valores $(x,y,z,v)$, onde $v$ é o valor associado e $(x)$,$(x,y)$ ou $(x,y,z)$ denota uma posição. Através deste modelo, é possível armazenar em um \textit{WiseMesh} o valor $v$ da pressão ao longo de uma árvore arterial na direção $x$ variando o valor da frequência no eixo $y$.

Os elementos servem como estruturas de armazenamento padrão que compõem um outro objeto. O ciclo de manipulação desses elementos se divide em três partes: (1) criação - os objetos podem ser criados a partir de exemplos pré-definidos ou através de um arquivo de entrada \textit{VTK} ou \textit{XML (eXtensible Markup Language)}; (2) iteração - processo em que o elemento com todas as estruturas definidas e consistentes é utilizado por um algoritmo; \igunew{(3) exibição - este último ciclo utiliza os dados armazenados nesta estrutura e gera um objeto para visualização.}

Todo elemento completo possui uma redundância de dados, podendo ser representado por qualquer uma das duas estruturas que o compõe. A estrutura \textit{WiseStructure} utiliza componentes simples para descrever as estruturas e seus parâmetros. Essa estrutura é a que mais se assemelha à encontrada na arquitetura \textit{VTK}. Por utilizar uma quantidade limitada de diretivas o arquivo proveniente dessa estrutura pode ser rapidamente lido, interpretado e até mesmo exportado.

\begin{figure}[!htbp]
	\includegraphics[width=0.5\textwidth]{Figures/WiseElementPoints@16x.png}
	\includegraphics[width=0.5\textwidth]{Figures/WiseElementLines@16x.png}
	
	\includegraphics[width=0.5\textwidth]{Figures/WiseElementCells@16x.png}
	\caption{Pontos, linhas e células para especificação do modelo geométrico.}
	\label{fig2:wiselementstructs}
\end{figure}

Os componentes de uma estrutura são pontos, células, linhas e campos. Pontos demarcam uma posição no espaço, células e linhas representam conjuntos de pontos e os campos são dados gerais da estrutura. Um modelo de pontos e linhas é capaz de representar o mesmo modelo geométrico de uma árvore arterial, basta considerar cada ponto uma bifurcação de vasos e cada segmento de vaso uma linha. Através destes componentes é possível armazenar e acessar dados sobre cada segmento. Para dados gerais do modelo, como a frequência $f$, são utilizados os campos da estrutura.

A classe \textit{WiseElement} foi desenvolvida para construir a estrutura abstrata (\textit{DataStructure}) a partir das informações contidas na estrutura (\textit{WiseStructure}). Desta forma é importante que a estrutura possa ser armazenada e recuperada rapidamente. O elemento é o elemento básico do método de iteração, sendo duplicado antes de ser iterado, gerando novas estruturas e abstrata idênticas. Imediatamente, a nova estrutura abstrata \textit{DataStructure} é descartada e os dados contidos na nova estrutura \textit{WiseStructure} são armazenados. Portanto, a estrutura abstrata não estará sempre presente. Seguindo este ciclo de vida, todos os elementos obedecem à máquina de estados contida na Figura~\ref{fig3:wiselementstatus}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=1.5]{Figures/WiseElementStatus@16x.png}
	\caption{Máquina de estados que controla o funcionamento de um elemento inteligente.}
	\label{fig3:wiselementstatus}
\end{figure}

A máquina de estados dos elementos gerencia o ciclo de vida deles. Inicialmente, os elementos recebem o estado \textit{Raw}, ou cru, que representa um elemento ainda sem estruturas carregadas ou sem consistência garantida. Uma vez que a estrutura é inserida e verificada o elemento muda para o status \textit{Warming} ou \textit{Cooling}, respectivamente esquentando ou esfriando.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=1.85]{Figures/WiseElementWarming@16x.png}
	\caption{Elemento no estado \textit{Warming}, \textit{Raw} e \textit{Cooling}.}
	\label{fig4:wiselementwarming}
\end{figure}

A Figura~\ref{fig4:wiselementwarming} mostra as estruturas presentes em elementos no estado \textit{Warming}, \textit{Raw} e \textit{Cooling}. Cada estado possui uma finalidade diferente e representa em que estado estão as informações do elemento. Elementos no estado \textit{Warming} estão aguardando a construção de sua estrutura abstrata, enquanto elementos  no estado \textit{Cooling} aguardam que seus dados sejam salvos em memória. Finalmente, elementos no estado \textit{Raw} indicam que não é esperada a consistência dos dados.

Inicialmente os elementos são criados no estado \textit{Raw}, enquanto os dados do elemento são carregados ele permanecerá neste estado. Ao final do carregamento o objeto trocará de estado para \textit{Warming} ou \textit{Cooling}, que indicam o próximo passo do elemento. Estar no estado \textit{Warming} indica que o objetivo é esquentar o objeto, atingindo o estado \textit{Hot}. Enquanto o estado \textit{Cooling} indica que a estrutura aguarda resfriamento, atingindo o estado \textit{Cold}. Quando os dados abstratos são criados corretamente para o elemento seu estado é definido como \textit{Hot}, neste estado todas as informações do objeto estão em memória, sendo este o estado mais pesado do elemento. Em contrapartida, o estado \textit{Cold} indica que a estrutura foi corretamente armazenada em disco e os elementos neste estado estão em seu estado mais leve, pois possuem em memória apenas o caminho para a estrutura armazenada.

Como ilustrado na Figura~\ref{fig3:wiselementstatus}, o estado \textit{Cold} está associado com o uso da memória para armazenamento de estruturas inteligentes. A estrutura do arquivo é equivalente a uma malha estruturada VTK, mas são efetivamente salvos em um arquivo \textit{XML}. Caso sejam novamente carregados por uma mudança de estado ou deletados o arquivo armazenado é deletado. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=1.85]{Figures/WiseElementCold@16x.png}
	\caption{Elemento no estado \textit{Cold}.}
	\label{fig5:wiselementcold}
\end{figure}

O estado \textit{Crashed} serve para identificar objetos que não tem mais o funcionamento esperado. Durante a troca de estados do elemento é verificado se as estruturas esperadas estão presentes, caso não estejam o objeto é direcionado a este estado.

Finalmente, o estado \textit{Hot} representa os elementos que possuem todas as estruturas presentes. Isto significa que a estrutura \textit{WiseStructure} e a estrutura abstrata equivalente \textit{DataStructure} estão presentes e são consistentes.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=1.85]{Figures/WiseElementHot@16x.png}
	\caption{Elemento no estado \textit{Hot}.}
	\label{fig6:wiseelementhot}
\end{figure}

Para que um elemento possa ser iterado ele precisa estar no estado \textit{Hot}, porque durante a iteração de um elemento seus dados abstratos são utilizados. A cada passo da iteração a estrutura \textit{DataStructure} é atualizada, exigindo uma atualização da estrutura \textit{WiseStructure}.

Seguindo o conceito de classes com propósito único, os elementos são responsáveis apenas por gerir os dados contidos na estrutura e abstrata. Portanto, as funções de criar, iterar e visualizar estas estruturas foram divididas em outras classes.

%--------------------------------------------------------------------------------%
\subsection{FÁBRICA DA CLASSE}\label{sec:fabrica} 

Como mencionado anteriormente, três principais barreiras foram identificadas armazenamento, iteração e visualização. Nesta seção, uma arquitetura de classes que permite a execução de cada passo através do paradigma de Fábricas Dinâmicas~ \cite{factorypattern} é proposta. Esta arquitetura com Fábricas que permitem a criação de instâncias com definições concretas armazenadas como metadados. Isso facilita a adição de novos objetos que podem ser interpretados sem modificar o código da fábrica em si. 

\igunew{A fábrica é uma classe que possui construtores de outras classes. Este tipo de classe permite que os métodos de construção do objeto sejam separados da lógica interna do objeto, sendo útil em classes com uma construção complexa. Sendo estas fábricas também classes virtuais, três principais tipos de fábricas foram idealizadas: (1) uma que cria os elementos, (2) uma que itera estes elementos e (3) uma que cria um elemento gráfico a partir de um elemento.}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.75\textwidth]{Figures/WiseElementWorkflow@16x.png}
	\caption{Arquitetura de classes fábrica e fluxo de trabalho do elemento \textit{WiseElement}. A fábrica \textit{WiseElementFactory} é responsável por criar o elementos, a fábrica \textit{WiseIterationFactory} é responsável pela iteração do elemento e a fábrica \textit{GraphicFactory} é responsável por criar as estruturas de visualização. }
	\label{fig2:wiselementsworkflow}
\end{figure}

Primeiramente, a fábrica de elementos \textit{WiseElementFactory} é utilizada para a criação de elementos, essa fábrica é utilizada para criar um elemento a partir de parâmetros pré-definidos. Esse tipo de fábrica é também uma classe virtual, seus métodos definem que fábricas de elementos possuem três maneiras de executar: \igunew{criar elementos à partir de uma lista de exemplos; criar elemento a partir de um arquivo \textit{VTK} ; e criar o elemento a partir de um arquivo \textit{XML}.}

Os métodos de criação de elementos são selecionados através do nome da fábrica e de um dos três métodos de criação. A ferramenta computacional possui uma lista com todas a fábricas disponíveis e as utiliza quando necessário. Devido à forma como os dados são carregados para cada elemento, é necessário que haja uma fábrica para cada tipo de elemento.

Similarmente, a fábrica \textit{WiseIterationFactory} só pode operar com um tipo específico de elemento. Entretanto, é possível que haja mais de uma fábrica de iteração disponível por tipo de elemento. Desta forma, uma árvore arterial pode ser iterada por diferentes algoritmos de iteração e o mesmo ocorre com os outros tipos de elementos. Estas fábricas são responsáveis por executar algum algoritmo que utilize o tipo de dados do elemento. No caso de uma árvore arterial é possível utilizar uma fábrica que irá executar o modelo matemático descrito na Seção~\ref{sec:algoritmo} utilizando os ponteiros para segmentos disponíveis em uma \textit{WiseArteryTree}.

Por último, a fábrica \textit{GraphicFactory} irá criar o objeto gráfico correspondente ao elemento. Assim como um elemento um objeto gráfico pode ser salvo em memória.  Um elemento é composto por todas as linhas, pontos, células e seus valores associados, enquanto um objeto gráfico contém as representações gráficas destas estruturas e permite a visualização destes valores associados. Os elementos estruturais de uma árvore arterial (seus pontos e linhas) são traduzidos em esferas e cilindros como visto na Figura~\ref{fig1:gui}. A cor destas esferas e cilindros representam algum valor associado à estrutura, apenas um valor pode ser exibido por vez ao longo da escala de cores, como o fluxo $Q$ ou a pressão $P$. Desta forma, os elementos gráficos só exigem que um parâmetro por vez seja armazenado.


%--------------------------------------------------------------------------------%
\subsection{OBJETO DA CLASSE}\label{sec:objeto_inteligente}

A classe que combina todas as estruturas utilizadas no método de iteração da ferramenta computacional foi nomeada de objeto \textit{WiseObject}. Este objeto preserva todos os passos de de iteração e poupa a quantidade de recursos mantida em memória. 

A classe \textit{WiseObject} é composta por um coleção de elementos e objetos gráficos equivalentes entre si. Nessa classe, a presença de uma fábrica gráfica é opcional, possibilitando que objetos sejam iterados sem que alguma estrutura seja disponibilizada para visualização. Utilizando a mesma separação de classes com propósito único, fábricas dinâmicas garantem que um objeto seja criado corretamente. As fábricas presentes na Seção~\ref{sec:fabrica} foram incluídas como propriedades de um objeto, desta forma estes objetos serão compostos por três fábricas: \textit{WiseElementFactory}, \textit{WiseIterationFactory} e \textit{GraphicFactory}.

\igunew{O objeto possuirá duas estruturas de armazenamento de elementos. O elemento guardado no \textit{Forno} será o objeto utilizado pelo algoritmo a cada iteração, portanto é sempre o mais recente. A cada ciclo iterativo o elemento contido no \textit{Forno} é duplicado e uma nova instância é adicionada ao \textit{Freezer}, estes elementos serão armazenados e recuperados quando necessário.}

O ciclo de vida de um objeto consiste na sua criação, a iteração de um modelo matemático e, opcionalmente, a exibição de um modelo gráfico. Objetos são criados com seu primeiro elemento. Ao criar um objeto, sua fábrica adiciona em sua estrutura a fábrica de elementos. Desta forma objetos são capazes de replicar seus elementos. No momento da criação, o primeiro elemento é duplicado e uma instância segue para o \textit{Forno}, enquanto a outra segue para o \textit{Freezer}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=1.15]{Figures/WiseObject@16x.png}
	\caption{Objeto \textit{WiseObject} e todos seu componentes:\textit{WiseObjectFactory}, fábrica responsável pela criação de objetos; \textit{WiseElementFactory}, fábrica responsável pela criação de elementos; \textit{WiseIterationFactory}, fábrica de iteração; \textit{WiseGraphicFactory}, fábrica gráfica; \textit{WiseCollection}, coleção de elementos; \textit{GraphicModel} coleção de objetos gráficos.}
	\label{fig7:wiseobject}
\end{figure}

Através do modelo de classes de um objeto presente na Figura~\ref{fig7:wiseobject} é possível identificar todos os componentes presentes em um objeto. O objeto troca seus elementos de estado automaticamente. A coleção de elementos \textit{WiseCollection} irá manter apenas um elemento em memória. O elemento contido no \textit{Forno} que deve permanecer no estado \textit{Hot}. Ao mesmo tempo a coleção irá manter um histórico de elementos armazenados no \textit{Freezer} que devem permanecer no estado \textit{Cold}. É possível que o objeto volte à um estado anterior, substituindo o elemento presente no \textit{Forno} com algum estado anterior armazenado no \textit{Freezer}. Dessa forma o elemento utilizado no método iterativo será o objeto recuperado. Ao realizar essa operação, a coleção de elementos irá recuperar a estrutura do elemento, alterando seu estado para \textit{Warming}, em seguida irá recriando seus dados abstratos utilizando a fábrica de elementos disponível, além de alterar seu estado para \textit{Hot}. Estas mudanças de estados são descritas pela máquina de estados do objeto na Figura~\ref{fig7:wiseobjectstatuses}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=2]{Figures/WiseObjectStatus@16x.png}
	\caption{Máquina de estados utilizada pelos objetos \textit{WiseObject}. O estado \textit{Ready} indica que o objeto foi criado corretamente e o estado \textit{Set} indica que o objeto teve suas fábricas corretamente adicionadas. Enquanto o objeto estiver iterando ele permanecerá no estado \textit{Go} e quando finalizar irá para o estado \textit{Finished}. O estado \textit{Crashed} é utilizado quando o objeto não funciona corretamente.}
	\label{fig7:wiseobjectstatuses}
\end{figure}

As trocas de estado dos objetos são causadas por operações do usuário para preparar o objeto para iteração e para executar o método de iteração. Desta forma, o usuário pode definir quais fábricas serão inseridas no objeto, os parâmetros do modelo geométrico do experimento e quais trocas de estados devem ser executadas.

Como objetos são criados a partir de um elemento, eles possuem os mesmos métodos de criação. Desta forma, as fábricas de objetos \textit{WiseObjectFactory} são compostas por fábricas de elementos \textit{WiseElementFactory}. Finalmente, com este modelo de classes, foram disponibilizadas duas formas de criar objetos inteligentes, utilizando um elemento já existente ou os métodos de criação de elementos disponíveis na fábrica de elementos.

Em seguida, é necessário definir qual será a lógica de iteração do objeto, adicionando uma fábrica de iteração \textit{WiseIterationFactory} compatível. Para o caso de escoamento pulsátil através de uma árvore arterial é necessário adicionar a fábrica de iteração correspondente ao algoritmo da Seção~\ref{sec:algoritmo} e em seguida definir os parâmetros desejados, como a frequência $f$, a viscosidade $\mu$ e o ângulo de fase $\phi$. Com as alterações concluídas o objeto passa a poder ser iterado, opcionalmente uma fábrica gráfica \textit{GraphicFactory} pode ser inserida. Neste caso, o objeto passará a gerar objetos gráficos \textit{GraphicObject} a cada iteração.

Inicialmente, um objeto é criado no estado \textit{Ready} somente com seu elemento inicial e uma fábrica do tipo \textit{WiseElementFactory}. Neste estado é esperada a inclusão das fábricas de iteração e gráfica. Uma vez que elas estejam corretamente acopladas ao objeto, é possível fazer a troca do estado \textit{Ready} para o estado \textit{Set}. Com a mudança de estado, é adicionado à estrutura \textit{WiseStructure} todos os parâmetros disponibilizados pelas fábricas de iteração e gráfica. Um objeto no estado \textit{Set} indica que o objeto foi corretamente criado, uma fábrica de iteração foi adicionada, possivelmente uma fábrica gráfica, e agora o objeto aguarda alterações nestes parâmetros ou execução do método iterativo.

Com os parâmetros definidos e as fábricas devidamente acopladas, o objeto está pronto para a iteração. O método iterativo de um objeto é representado na transição para o estado \textit{Go}. Uma iteração de uma \textit{WiseArteryTree} representa o cálculo dos valores de pressão e fluxo em toda a árvore arterial. Caso algum erro ocorra durante o processamento de dados o objeto se desloca para o estado \textit{Crashed}, assim como elementos. É possível também finalizar a execução de um objeto ao enviá-lo para o estado \textit{Finished}, neste estado o objeto não poderá ser iterado novamente. Para que parâmetros da iteração possam ser alterados sem que se perda elementos, é possível que um objeto no estado \textit{Go} retorne para o estado \textit{Set}. Todas estas trocas de estados são gerenciadas pela máquina de estado apresentada na Figura~\ref{fig7:wiseobjectstatuses}.

%--------------------------------------------------------------------------------%
\subsection{OBJETO GRÁFICO DA CLASSE}\label{sec:objeto_grafico}


Quando o objeto \textit{WiseObject} estiver corretamente carregado e uma fábrica gráfica \textit{GraphicFactory} for adicionada à sua estrutura o primeiro objeto gráfico \textit{GraphicObject} de sua coleção será criado. Assim como um elemento representa uma iteração, um objeto gráfico representa um ciclo iterativo. Enquanto a estrutura responsável por elementos, \textit{WiseCollection}, é responsável por manter os últimos dados de iteração aquecidos, a coleção de objetos gráficos \textit{GraphicModel} mantém o objeto que está sendo exibido por alguma tela. As coleções tem como objetivo manter seus elementos e realizar trocas de estados quando necessário. No caso dos elementos, somente o último objeto é necessário e o mesmo ocorre no contexto dos objetos gráficos, apenas o objeto exibido em um elemento da interface de usuário e seus vizinhos serão mantidos em memória.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=2]{Figures/GraphicModel@16x.png}
	\caption{Modelo gráfico \textit{GraphicModel} contém uma coleção de objetos gráficos.}
	\label{fig7:graphicmodel}
\end{figure}

Na Figura~\ref{fig7:graphicmodel} estão os componentes que permitem armazenar todos os quadros da animação final. Quando um objeto \textit{WiseObject} está corretamente configurado com uma instância de fábrica gráfica \textit{GraphicFactory}, seu método iterativo é atrelado à criação de objetos gráficos. Isso permite que o objeto iterado crie um elemento \textit{WiseElement} e um objeto gráfico \textit{GraphicObject} a cada iteração.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=2]{Figures/GraphicObjects@16x.png}
	\caption{Tipos de objetos gráficos \textit{GraphicObjects}, representando cada tipo de elemento \textit{WiseElement}. O objeto \textit{Graphic} representa um gráfico, o objeto \textit{Mesh} uma malha, o objeto \textit{Poly} um cubo e o objeto \textit{ArteryTree} uma árvore arterial.}
	\label{fig7:graphicobjects}
\end{figure}

Cada objeto gráfico é desenhado através de diretivas OpenGL. O formato do modelo geométrico é apresentado ao usuário através das formas geométrica, enquanto algum parâmetro do elemento \textit{WiseElement} é visualizado através de uma escala de cores.

Os objetos gráficos contidos na Figura~\ref{fig7:graphicobjects} possuem métodos específicos para desenhá-lo utilizando uma escala de cores e formas geométricas padrão, bidimensionais ou tridimensionais. Cada forma geométrica utilizada é representada por elementos gráficos \textit{GraphicElement}. A cada iteração a fábrica utilizará o elemento contido na estrutura \textit{Forno} e irá retirar a informação do elemento mais atual. Cada objeto gráfico possui um valor máximo e mínimo que é vinculado à escala cores. Logo as cores representam os valores armazenados em cada objeto gráfico.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=2]{Figures/GraphicElements@16x.png}
	\caption{Tipos de elementos gráficos \textit{GraphicElements}. \textit{Point}, um ponto. \textit{Line}, uma linha. \textit{Quad}, um quadrado. \textit{Cube}, um cubo. \textit{Cylinder}, um cilindro. \textit{Sphere}, uma esfera.}
	\label{fig7:graphicelements}
\end{figure}

Os elementos gráficos podem ser utilizados por qualquer tipo de objeto gráfico. A representação geométrica de uma árvore arterial é construída utilizando cilindros e esferas, que representam segmentos de vaso e terminais, respectivamente. Por padrão, os cilindros receberão uma lista de valores da pressão $P(X)$ para $\forall X \in [0,1]$, enquanto as esferas receberão os valores da pressão $P(X)$ quando $X=0$ ou $X=1$, condicionado a escolha do nó distal ($X=1$) ou o nó proximal~($X=0$).  Assim como os objetos \textit{WiseObject} têm seus tipos definidos pelo tipo de elemento, o objeto gráfico \textit{GraphicObject} tem seu tipo definido pelo elemento que representa com sua fábrica própria.

\igunew{Nesta estrutura gráfica ficam presentes o modelo geométrico, a escala de cores utilizada e o parâmetro a ser visualizado}. Apesar do objeto gráfico \textit{GraphicObject} ser uma redundância dos dados armazenados em um elemento \textit{WiseElement}, ele é menor \igunew{por conter somente um dos parâmetros armazenado}, podendo ser carregado e armazenado mais rapidamente. O objetivo das estruturas \textit{GraphicModel}, \textit{GraphicObject} e \textit{GraphicElement} é permitir que diversos objetos gráficos \textit{GraphicObjects} possam ser armazenados  e rapidamente carregados em memória. Os objetos gráficos em sequência representam uma animação que pode ser visualizada através da interface gráfica. 


%--------------------------------------------------------------------------------%
\subsection{PROJETO DA CLASSE}\label{sec:projeto}

O projeto \textit{WiseProject} é o escopo de trabalho da ferramenta computacional e são utilizados na organização dos objetos. O primeiro passo para utilizar a ferramenta é criar um projeto que irá conter todos os objetos e elementos criados.


\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=2]{Figures/WiseProject@16x.png}
	\caption{Projeto \textit{WiseProject} e seus componentes, uma lista de objetos \textit{WiseObject} e uma lista de elementos \textit{WiseElement}.}
	\label{fig7:project}
\end{figure}

Como ilustrado na Figura~\ref{fig7:project}, o projeto inteligente é representado por duas coleções, uma de elementos \textit{WiseElement} e outra de objetos \textit{WiseObject}. Os comandos recebidos pela ferramenta computacional terão efeito apenas sobre um projeto e suas coleções. Por exemplo, quando um elemento for utilizado na criação de um objeto eles devem estar no mesmo projeto.

O projetos é uma estrutura organizaciona. Pois, quando um comando é executado sobre objetos de um projeto, estes objetos são bloqueados pelo projeto até o final da execução do comando. Enquanto permanecer bloqueado um objeto não pode ser excluído ou alterado por outro comando. Ao excluir um projeto, todas as demandas devem ser finalizadas. Finalmente, as estruturas dos projetos podem ser salvas e carregadas, portanto estas estruturas também servem para armazenar experimentos inteiros e seus resultados.

%--------------------------------------------------------------------------------%
\subsection{FÁBRICA DE PROJETO DA CLASSE}\label{sec:fabrica_projeto} 

O conceito de fábrica foi adicionado ao projeto para padronizar a construção de objetos. Inclusa neste conceito, a fábrica de projetos \textit{WiseProjectFactory} é responsável pela construção de projetos. Diferentemente das outras, a  \textit{WiseProjectFactory} contém todas as fábricas suportadas pela ferramenta computacional.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=1.5]{Figures/WiseProjectFactory@16x.png}
	\caption{Fábrica de projeto\textit{WiseProjectFactory} e seus componentes: fábricas de elementos \textit{WiseElementFactories}, fábricas de objetos \textit{WiseObjectFactories}, fábrica de objetos gráficos \emph{Gra}\-\emph{phic}~\-\emph{Object}~\-\emph{Facto\-ries}, fábricas de elementos gráficos \textit{GraphicElementFactories} e fábricas de iteração \textit{WiseIterationFactories} .}
	\label{fig7:projectfactory}
\end{figure}

Como é possível observa na Figura~\ref{fig7:projectfactory}, a fábrica de projetos inteligentes é composta de outras coleções de fábricas, agrupadas pelo tipo de estrutura que criam. Nesta classe estão as fábricas de elementos \textit{WiseElement}, objetos \textit{WiseObject}, objetos gráficos \textit{GraphicObject}, elementos gráficos \textit{GraphicElement} e iteração \textit{WiseIterationFactory}. Por exemplo, quando um projeto contendo diversas árvores arteriais e gráficos é carregado ele é construído pela fábrica de projetos. A fábrica de projetos irá reconhecer o formato de cada estrutura e encaminhar para a fábrica correspondente.

\begin{figure}
	\begin{tabularx}{\textwidth}{cc}
		\includegraphics[width=0.5\linewidth]{Figures/WiseElementFactories@16x.png} &   \includegraphics[width=0.5\linewidth]{Figures/WiseObjectFactories@16x.png} \\
		(a) Fábricas de elementos & (b) Fábricas de objetos \\[6pt]
		\includegraphics[width=0.5\linewidth]{Figures/GraphicObjectFactories@16x.png} &   \includegraphics[width=0.5\linewidth]{Figures/GraphicElementFactories@16x.png} \\
		(c) Fábricas de objetos gráficos & (d) Fábricas de elementos gráficos \\[6pt]
		\multicolumn{2}{c}{\includegraphics[width=0.5\linewidth]{Figures/WiseIterationFactories@16x.png} }\\
		\multicolumn{2}{c}{(e) Fábricas de iteração}
	\end{tabularx}
	\caption{Todas as fábricas que compõem uma fábrica de projeto.}
	\label{tab:factories} 
\end{figure}

 As fábricas de iteração descritas na Figura~\ref{tab:factories} foram criadas para resolver o modelo matemático descrito na Seção~\ref{sec:modelo_matematico} e extrair o seu resultado. A fábrica de iteração estática \textit{StaticIterationFactory} é uma fábrica que não altera o objeto inteligente no processo de iteração, esta é a única classe de iteração que pode ser utilizada em mais de um tipo de objeto, podendo ser executada em qualquer tipo de objeto inteligente.

O modelo do escoamento pulsátil proposto está presenta na fábrica de iteração \textit{DuanAndZamirIterationFactory}, esta fábrica é responsável por utilizar a estrutura de uma árvore arterial \textit{WiseArteryTree} e aplicar o modelo matemático. Finalmente, a fábrica de iteração \textit{WiseObjectDataReadIterationFactory} é uma fábrica responsável por armazenar os resultados obtidos a cada iteração e armazenar em uma estrutura do tipo \textit{WiseMesh}.

%--------------------------------------------------------------------------------%
\subsection{THREADS DA CLASSE \textit{WiseThreadPool}}\label{sec:threads}

Até o momento as estruturas foram construídas utilizando conceitos padrões da linguagem C++, herança de propriedades através do polimorfismo, ponteiros, classes virtuais e fábricas dinâmicas. Nesta seção o conceito de programação paralela e divisão de tarefas acoplado à ferramenta computacional é proposto.

\igunew{A arquitetura de computadores atual permite aos usuários da aplicação executar processos que irão utilizar os recursos físicos do computador. O processador é a unidade central de processamento que executa milhões de tarefas por segundo. No entanto, executa apenas uma instrução por vez. Quando diversos processos estão em execução no computador o sistema operacional é responsável por balancear o tempo de processamento que cada processo ganha, com isso somos capazes de executar diversos programas ao mesmo tempo, este ciclo é conhecido como escalonamento de processos.}

\igunew{Processadores mais recentes estão equipados com múltiplos núcleos de processamento, o que permite a execução de diversas tarefas ao mesmo tempo. Para que um único processo tire vantagem desta arquitetura ele precisa se reestruturar em \textit{threads}, estes elementos são partes do processo e cada uma possui seu próprio ciclo de execução e é avaliado separadamente no escalonamento de processo. Desta forma, um processo é capaz de se beneficiar de uma arquitetura com múltiplos núcleos. Entretanto, é necessária uma reorganização do processo uma vez que todas as \textit{threads} irão dividir o mesmo espaço de memória. Como cada \textit{thread} possui o seu próprio ciclo de execução, para que possam trocar informações é necessário que haja um tratamento para possibilitar a comunicação assíncrona.}

Observou-se que as estruturas possuem comportamentos padronizados e que um objeto é autônomo. Ele sozinho é capaz de se armazenar, reconstruir, iterar e ocasionalmente se desenhar. Imaginando um cenário em que diversos objetos estão iterando, as tarefas foram divididas em três tipos de \textit{Threads}, primeiramente trabalhos de leitura e escrita, em seguida a iteração dos objetos. 

Estes objetos estão disponíveis para todas as \textit{threads} através do projeto \textit{WiseProject} e são enviados por referência no trabalho \textit{WiseJob} caso não estejam bloqueados. Desta forma, computadores com múltiplos núcleos podem fazer uso de suas \textit{threads} e permitir que mais de um objeto realize suas tarefas por vez.

Ao longo da pesquisa a estrutura de classes foi agregada as bibliotecas comuns do Qt 5.15.0 \cite{QTClasses}, em um primeiro momento, para facilitar a visualização dos resultados através dos elementos gráficos de interface de usuários disponibilizados. Em seguida, permitiu o processamento de elementos de forma paralela. Com isso um modelo que suportasse o processamento paralelo utilizando classes \textit{QThreads}, que possuem tarefas concorrentes, foi construído.


\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{Figures/WiseThreadPool@16x.png}
	\caption{Modelo de \textit{Threads}. \textit{WiseThreadPool}, responsável por orquestrar o funcionamento das demais \textit{threads}, bem como os objetos contidos em um projeto \textit{WiseProject}. \textit{WiseIO}, \textit{thread} responsável por processos de leitura e escrita. \textit{WiseConsole}, \textit{thread} responsável por interpretar os comandos de texto e traduzir-los na chamada de métodos. \textit{WiseProcessor}, \textit{thread} responsável por realizar o método iterativo de um objeto  \textit{WiseObject}}
	\label{fig7:threads}
\end{figure}

As tarefas se dividem em três principais grupos: tarefas auxiliares, tarefas de leitura/escrita e trabalhos de iteração. O principal trabalho auxiliar é interpretar os comandos recebidos pelo programa e então criar a instância de trabalho \textit{WiseJob}. Sendo os grupos de tarefas mais custosos os de tarefas de escrita/leitura e iteração, eles foram divididos em \textit{threads} específicas chamadas de \textit{WiseIO} e \textit{WiseProcessor}, respectivamente.

Os objetos distribuídos \textit{threads} contidos na Figura~\ref{fig7:threads} possuem um ciclo próprio, portanto executam tarefas assíncronas e precisam de tratamento adequado. O sistema de sinais e fendas disponibilizado pelas bibliotecas comuns do Qt permitem que as \textit{threads} se comuniquem assincronamente através do envio de mensagens. Estas mensagens são chamadas de trabalhos \textit{WiseJobs}, cada uma possuindo sua atividade relacionada e objeto relacionado. Uma vez criados, os trabalhos são alocados a sua respectiva categoria de \textit{thread} passando por um balanceamento executado pelo gerenciador de threads \textit{WiseThreadPool}. Enquanto o processamento é feito, todos os dados relativos ao processamento são bloqueados, isso previne a sobrescrita de dados quando há mais de uma \textit{thread} trabalhando.

O gerenciador de \textit{threads} \textit{WiseThreadPool} é composto por \textit{threads} que executam os trabalhos e por projetos \textit{WiseProject} que criam trabalhos \textit{WiseJobs}. Ao executar um comando de texto, a linha de entrada será recebida pelo gerenciador e o primeiro trabalho \textit{WiseJob} será criado. Em seguida, será interpretado pelas \textit{threads} do grupo de tarefas auxiliares \textit{WiseConsole}, caso seja um trabalho de leitura, escrita ou iteração um trabalho associado será criado e enviado ao gerenciador de \textit{threads}. Caso não seja um trabalho desses tipos ele será executado na \textit{thread} atual e o trabalho finalizado. O console \textit{WiseConsole} funciona como interpretador principal dos comandos e das mensagens, ao receber uma linha de texto este objeto irá analisar seu conteúdo e executar a ação correspondente.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{Figures/WiseThreaPoolCMD@16x.png}
	\caption{Modelo de \textit{Threads} ao receber uma linha de comando da interface de usuário.}
	\label{fig8:threads}
\end{figure}

Quando se trata de um comando de escrita ou leitura, a \textit{thread} \textit{WiseIO} é utilizada. Ao receber esse tipo de comando o console irá listar o trabalho no gerenciador de threads \textit{WiseThreadPool}. O gerenciador irá balancear as requisições entre as \textit{threads} e em seguida o gerenciador de \textit{threads} irá aguardar uma mensagem indicando o final da execução do trabalho. Quando um objeto \textit{WiseObject} é iterado um elemento é criado na estrutura \textit{Freezer}, gerando uma requisição através de um trabalh. Portanto, a \textit{thread} \textit{WiseIO} é muito utilizada no ciclo de vida de um elemento, gerenciando o processo de armazenamento e reconstrução do mesmo. Esta estrutura é que efetivamente aquece e resfria os elementos.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{Figures/WiseThreadPoolHeating@16x.png}
	\caption{Modelo de Threads ao receber um comando de escrita/leitura.}
	\label{fig9:threads}
\end{figure}

Os trabalhos de iteração funcionam da mesma forma que as de leitura ou escrita, entretanto são enviadas a \textit{threads} \textit{WiseProcessor}. Estas \textit{threads} não possuem lógicas muito complexas e são responsáveis apenas por gerenciar os objetos e executar os métodos requisitados. Por este motivo, os objetos e elementos possuem métodos abstratos e seguem esses conjuntos de regras para que uma estrutura que desconheça o seu funcionamento ou suas estruturas internas sejam capazes de executar métodos padrões. 

Mesmo com a arquitetura de \textit{threads} inclusa na ferramenta computacional ainda é possível que ela seja executada em processadores com apenas um núcleo, neste caso mais \textit{threads} \igunew{não irão tornar a ferramenta mais rápida}, pois apesar dos trabalhos ainda serem dividos em \textit{threads} diferentes, elas serão executadas no mesmo núcleo de processamento. Além disto, existe um custo computacional pela comunicação entre threads, portanto com apenas um núcleo a arquitetura de classes divididas em \textit{threads} se torna uma desvantagem. As \textit{threads} têm um impacto maior nas atividades de escrita e leitura, isto porque o objeto está dividido em várias estruturas menores que são armazenadas e acessadas constantemente, principalmente no caso de uma animação gráfica.

Ainda dentro do gerenciador de \textit{threads} existem quatro listas de espera:

\begin{itemize}
	\item \textit{Pre-Queue (Pre-Q)}: Lista de pré-seleção. Nesta estrutura, os trabalhos são agrupados por grupo de trabalho e ordenados por data de criação;
	\item \textit{Queue (Q)}: Lista de espera para trabalhos que aguardam sua alocação em \textit{threads} adequadas;
	\item \textit{Running}: Lista de trabalhos que já foram enviados as suas respectivas \textit{threads} e aguardam resposta;
	\item \textit{Finished}: Lista de trabalhos que já terminaram o seu ciclo de execução.
\end{itemize}

No momento de criação os objetos são adicionados à lista \textit{Pre-Q}. A cada ciclo da \textit{thread} \textit{WiseThreadPool}, os trabalhos da lista \textit{Pre-Queue} são enviados a lista de espera \textit{Queue}, os trabalhos de cada carga de trabalho são selecionados e enviados caso não haja pré-requisitos. A única exceção é a carga de trabalho utilizada pela ferramenta para armazenar e recuperar objetos rapidamente, para isto foi reservada um identificador da carga de trabalho.

Os trabalhos na lista de espera \textit{Queue} são balanceados entre as \textit{threads} disponíveis utilizando uma distribuição uniforme. Uma vez alocados, os trabalhos passam para a lista de trabalhos \textit{Running}, que contém os trabalhos em execução.

Ao final da execução em uma \textit{thread} separada, a estrutura armazena os trabalhos finalizados em uma lista \textit{Finished}, que finalizaram seu processamento em uma \textit{thread} concorrente e uma resposta foi recebida pelo gerenciador de \textit{threads}.

%--------------------------------------------------------------------------------%
\subsection{OBJETO DA CLASSE \textit{WiseThreadPool}}\label{sec:trabalhos}

Para que a comunicação entre as \textit{threads} \textit{WiseThreads} seja feita de forma padronizada e possa ser estendida futuramente, ao receber alguma demanda, o gerenciador de \textit{thread} \textit{WiseThreadPool} irá criar um objeto do tipo \textit{WiseJob}. Este objeto contém os seguinte parâmetros:

\begin{itemize}
	\item \textit{ID}: número de identificação único;
	\item \textit{Workload}: número de carga de trabalho;
	\item \textit{Arg}: cadeia de caracteres opcional, pode conter parâmetros para a execução do trabalho;
	\item \textit{Type}: tipo de trabalho;
	\item \textit{Status}: estado do trabalho;
	\item \textit{Antecessors}: lista de trabalhos que antecedem este na ordem de chamada;
	\item \textit{Pre-requisites}: lista de trabalhos que antecedem este na ordem de execução, ou seja, precisam ser finalizados antes;
	\item \textit{Ponteiros}: o trabalho do tipo \textit{WiseJob} pode ter um ponteiro para as estruturas da ferramenta computacional.
\end{itemize}

O número de identificação do trabalho é único e incremental, a carga de trabalho representa o grupo em que o trabalho irá executar. Ao executar a leitura de um arquivo de entrada, cada linha do arquivo irá ser interpretada como um comando e adicionada ao mesmo grupo de trabalho e vinculada ao último comando pela lista de antecessores \textit{Antecessors}, o que garante que eles serão executados em ordem.

O tipo \textit{Type} do trabalho é um identificador dado ao mesmo após sua interpretação inicial. Este identificador permite às \textit{threads} determinar qual a composição do objeto e quais parâmetros para execução foram preenchidos, como ponteiros e linhas de entrada. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{Figures/WiseJobStatus@16x.png}
	\caption{Máquina de estados utilizadas por trabalhos \textit{WiseJobs}.}
	\label{fig9:wise_jobs}
\end{figure}

Os estados de um trabalho são ditados pela sua máquina de estados representada na Figura~\ref{fig9:wise_jobs}. Os estados desta máquina indicam em qual estrutura da \textit{WiseThreadPool} o trabalho está e se seu funcionamento é adequado. O estado \textit{Setting} indica que o trabalho foi criado e está na lista de seleção \textit{Pre-Q}; o estado \textit{Queued} significa que o trabalho foi adicionado à fila de espera e aguarda execução; o estado \textit{Running} indica que o trabalho está sendo executado; o estado \textit{Finished} indica que o trabalho foi finalizado corretamente; e, o estado \textit{Zombie} indica que o trabalho não foi finalizado corretamente. 

\igunew{No cerne da biblioteca \textit{Qt} está a classe \textit{QObject}, que possui o mecanismo de comunicação entre objetos de sinais e fendas. Para que um objeto possa utilizar desta interface de comunicação é necessário que ele herde as características da classe \textit{QObject} por polimorfismo~\cite{QTClasses}.}

Os objetos de trabalho servem como mensagens de comunicação entre as \textit{threads}. Através desta estrutura objetos do tipo \textit{QObject} podem se comunicar e executar a requisição de trabalhos complexos. Isto foi feito para permitir que estruturas \textit{QWidget}, que são elementos gráficos da interface de usuário e herdam da classe \textit{QObject}, pudessem enviar mensagens diretamente ao gerenciador de \textit{threads}. \igunew{Os objetos \textit{QWidget} são elementos gráficos como o quadro \textit{OpenGL}, uma caixa de texto ou um botão. Todos os objetos desta classe enviam sinais a outro \textit{QObject} ao interagir com o usuário, como o uso de comandos de teclado e/ou mouse. Através da comunicação dos objetos da classe \textit{QObject} é possível que comandos na interface usuário acionem as funcionalidades das \textit{threads} e dos objetos.}